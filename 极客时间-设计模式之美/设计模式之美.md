## 评判标准

**可维护性**、**可读性**、**可扩展性**、灵活性、简洁性、可复用性、可测试性

### 扩展性

扩展性是代码质量最重要的衡量标准之一。再23种经点设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则是开闭原则。

## 方法论

面向对象设计思想、设计原则、设计模式、编码规范、重构技巧

### 编程风格

面向过程、面向对象、函数式编程

### 面向对象

- 封装、抽象、继承、多态
- 面向对象分析、面向对象设计、面向对象编程

#### 面向对象编程

一种编程范式或编程风格，它以类或者对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石。

#### 面向对象编程语言

是支持类或对象的语法机制，并由现成的语法机制，能方便地实现面向对象编程四大特性的编程语言。

如果按照严格的定义，需要有现成的语法支持类、对象、四大特性才能叫卖你想对象编程语言。如果放宽要求，只要某种编程语言支持类、对象语法机制，那基本上就可以说这种编程语言是面向对象编程语言了，不一定非得要求具有所有的四大特性。

#### 关系

面向对象编程一般使用面向对象编程语言来进行，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来，即使我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。

#### 封装

隐藏信息，保护数据。

一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。

#### 抽象

隐藏方法，让使用者只关心方法提供了哪些功能，不需要知道如何实现的。

一方面提高了代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。

#### 继承

解决代码复用问题。

#### 多态

提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。

#### 与面向过程比较

对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。

具有更加丰富的特性，利用这些特性编写出来的代码，更加易扩展、易服用、易维护。

更加人性化、更加高级、更加智能。

#### 假面向对象

1. 滥用 getter、setter 方法
2. Constants类、Utils 类的设计
3. 基于贫血模型的开发模式

#### 抽象与接口

##### 语法特性

抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。

##### 存在的意义

抽象类是对成员变量和方法的抽象，是一种 is-a 关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种 has-a 关系，表示具有某一组行为的特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。

##### 应用场景区别

如果要表示一种 is-a 的不谙悉，并且是为了解决代码复用问题，就用抽象类；如果要表示一种 has-a 关系，并且是为了解决抽象而非代码复用问题，就用接口。

### 设计思想

- 基于接口而非实现编程
- 多用组合少用继承

#### 基于接口而非实现编程

1. 这条原则的另一个表述方式是 **基于抽象而非实现编程**。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。
2. 在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。
3. **基于接口而非实现编程** 这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的 “接口” 设计、类库的 “接口” 设计。

#### 多用组合少用继承

##### 为什么

虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下应该尽量少用，甚至不用继承。

##### 组合的优势

继承主要作用有：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。

##### 该用组合还是继承？

组合并不是完美的，继承也并非一无是处。实际开发中，完美要根据具体的情况，来选择继承或组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，完美就可以大胆地使用继承。反之，完美就尽量使用组合来代替继承。除此之外，还有一些设计模式、特殊地应用场景，会固定使用继承或者组合。

### 设计原则

- SOLID 原则 -SRP 单一职责原则
- SOLID 原则 -OCP 开闭原则
- SOLID 原则 -LSP 里氏替换原则
- SOLID 原则 -ISP 接口隔离原则
- SOLID 原则 -DIP 依赖倒置原则
- DRY原则
- KISS原则
- YAGNI原则
- LOD法则

#### 单一职责原则

##### 作用

一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计颗粒度小、功能单一的类。单一职责原则是为了实现代码的高内聚、低耦合，提高代码的复用性、可读性、可维护性。

##### 如何判断

类中的代码行数、函数或者属性过多；

类依赖的其他类过多，或者依赖的类的其他类过多；

私有方法过多；

比较难给类起一个合适的名字；

类中大量的方法都集中操作类中的某几个属性。

##### 越单一越好？

单一职责原则通过避免设计大而全的累，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是如果拆分得过细，实际上会适得其反，反倒会降低内举行，也会影响代码得可维护性。

#### 开闭原则

##### 理解

添加一个新功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。有两点要注意，第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗粒度下，可能被认定为“修改”；在细粒度下，可能又被认定为“扩展”。

##### 如何做

具备扩展意识、抽象意识、封装意识。设计代码结构时，事先留好扩展点。

很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为目的的。23种经点设计模式。最常用的代码扩展性方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式：装饰、策略、模板、职责链、状态。

#### 里氏替换原则

##### 理解

里氏替换原则，最核心的就是理解“design by contract，按照协议来设计”。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现罗技，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。

##### 多态

多态时面向对象编程的一大特性，也是面向对象编程语言的一种语法。他是一种代码实现思路。而里氏替换时一种设计原则，用来知道继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。

#### 接口隔离原则

##### 理解

1. 理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分金额口制备部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。
2. 如果把“接口”理解为单个API接口或函数，部分调用者只需要函数中的部分功能，那么我们就徐娅把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。
3. 如果把“接口”理解为OOP中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现者和调用者，依赖不需要的接口函数。

##### 单一职责原则

单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够指责单一。

#### 依赖倒置

##### 控制反转

实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来知道架构层面的设计。“控制”是指对程序执行流程的控制，而“反转”指的是再没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。

##### 依赖注入

依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过new的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部建好之后，通过构造函数、函数参数等方式传递（注入）给类来使用。

##### 依赖注入框架

我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的声明周期、依赖注入等原本需要程序员来做的事情。

##### 依赖倒置

跟控制反转有点类似，主要用来知道框架层面的设计。高层模块不依赖底层模块，他们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

#### KISS原则与YAGNI原则

**KISS：**Keep It Simple and Stupid

**YAGNI：**You Ain't Gonna Need It

KISS原则是保持代码可读性和可维护性的重要手段。

KISS原则中的“简单”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。

本身就复杂的问题，用复杂的方法解决，并不违背KISS原则。

同样的代码，在某个业务场景下满足KISS原则，换一个应用场景可能就不满足了。

如何写出满足KISS原则代码的指导原则：

1. 不要使用同时可能不懂的技术来实现代码；
2. 不要重复造轮子，要善于使用已经有的工具类库；
3. 不要过度优化。

#### DRY原则

##### DRY

三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复

实现逻辑重复，但功能语义不重复的代码，并不违反DRY原则。

实现逻辑不重复，但功能语义重复的代码，也算违反DRY原则。

代码执行重复也算违反DRY原则。

##### 代码复用性

提高代码复用性的方法：

- 减少代码耦合
- 满足单一职责原则
- 模块化
- 业务与非业务逻辑分离
- 通用代码下沉
- 继承、多态、抽象、封装
- 应用模板设计模式

#### 迪米特法则

##### 高内聚松耦合

能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。高内聚用来指导类本身的设计，松耦合用来指导类与类之间依赖关系的设计。

高内聚是指相近的功能应该放到同一个类种，不想进的功能不要放到同一个类中。

松耦合是指，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。

##### 迪米特法则

不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这以变化的类就会比较少。

### 设计模式

#### 创建型

单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。

#### 结构型

代理模式、桥接模式、装饰者模式、适配器模式

#### 行为型

观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。

### 编程规范

// TODO：最能改善代码质量的20条规范

### 重构

重构的目的（why）、对象（what）、时机（when）、方法（how）

### 五者之间的联系

- 面向对象编程是很多设计原则、设计模式等编码实现的基础。
- 设计原则是指导我们代码设计的一些经验总结
- 设计模式是针对一些设计问题，总结出来的一套解决方案或者设计思路
- 编程规范主要解决的是代码的可读性问题
- 重构利用面向对象、设计原则、设计模式、编码规范这些理论来保持代码质量不下降



## 架构设计

### MVC

#### 贫血模型与充血模型

MVC三层架构是基于贫血模型地传统开发模式，是典型的面向过程的编程风格。相反，基于充血模型的DDD开发模式，是典型的面向对象的编程风格。

不过，DDD也并非银弹。对于业务不复杂的系统开发来说，基于贫血模型的传统开发模式简单够用，基于充血模型的DDD开发模式有点大材小用，无法发挥总用。相反，对于业务复杂的系统开发来说，基于充血模型的DDD开发模式，因为前期需要在设计上投入更多时间和精力，来提高代码的复用性和可维护性，所以比基于贫血模型的开发模式，更加有优势。



### UML

#### 六种类关系

##### 泛化

可以简单理解为继承关系

##### 实现

一般指接口和实现类之间的关系

##### 关联

包含聚合、组合两种关系

##### 聚合

是一种包含关系，A类对象包含B类对象，B类对象的声明周期可以不依赖A类对象的生命周期，可以单独销毁A类对象而不影响B对象

##### 组合

也是一种包含关系，A类对象包含B类对象，B类对象的生命周期依赖A类对象的生命周期，B类对象不可单独存在

##### 依赖

不管B类对象是A类对象的成员变量，还是A类的方法使用B类对象作为参数或者返回值、局部变量，只要B类对象和A类对象有任何使用关系，完美都称它们有依赖关系



### 面向对象设计

1. **划分职责进而识别出有哪些类**

   根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。

2. **定义类及其属性和方法**

   我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为侯选属性，然后同样再进行过滤筛选。

3. **定义类与类之间的交互关系**

   UML统一建模语言中定义了六种类之间的关系。它们分别是：泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留四个关系：泛化、实现、组合、依赖。

4. **将类组装起来并提供执行入口**

   我们要将所有类组装在一起，提供一个执行入口。这个入口可能是一个main()函数，也可能是一组给外部调用的API接口。通过这个入口，我们能触发整个代码跑起来。











































